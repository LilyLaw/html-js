<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>存在性</title>
</head>
<body>
	<script>
		// 如myObject.a 的属性访问返回值可能是undefined，但是这个值有可能是属性中存储的undefined，也可能是因为属性不存在所以返回undefined。那么如何区分这两种情况呢？
		// 如下代码：
		// var myObject = {
		// 	a: 2
		// };
		// console.log("a" in myObject); // true
		// console.log("b" in myObject); // false
		// console.log(myObject.hasOwnProperty("a")); // true
		// console.log(myObject.hasOwnProperty("b")); // false
		// in 操作符会检查属性是否在对象及其[[Prototype]]原型链中。相比之下，hasOwnProperty(..) 只会检查属性是否在myObject 对象中，不会检查[[Prototype]] 链。
		// 所有的普通对象都可以通过对于Object.prototype 的委托来访问hasOwnProperty(..)，但是有的对象可能没有连接到Object.prototype（ 通过Object.create(null) 来创建）。在这种情况下，形如myObejct.hasOwnProperty(..)就会失败。这时可以使用一种更加强硬的方法来进行判断：Object.prototype.hasOwnProperty.call(myObject,"a")，它借用基础的hasOwnProperty(..) 方法并把它显式绑定到myObject 上。


		// 注意：in 操作符实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的True，因为[2, 4, 6] 这个数组中包含的属性名是0、1、2，没有4。
		var arr = [7,11,8,12,6];
		console.log(8 in arr);
	</script>
</body>
</html>