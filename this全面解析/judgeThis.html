<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>判断this是哪种类型</title>
</head>
<body>
	<script>
		// 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：
		// 1. 函数是否在new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。
		// 	var bar = new foo()
		// 2. 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。
		// 	var bar = foo.call(obj2)
		// 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
		// 	var bar = obj1.foo()
		// 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
		// 	var bar = foo()


		// 例外情况
		// 1　被忽略的this
		// 	如果你把null 或者undefined 作为this 的绑定对象传入call、apply 或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：
		// 	function foo() {
		// 		console.log(this.a);
		// 	}
		// 	var a = 2;
		// 	foo.call(null); // 2
		// 那么什么情况下你会传入null 呢？
		// 一种非常常见的做法是使用apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：
		function foo(a, b) {
			console.log("a:" + a + ", b:" + b);
		}
		// 把数组“展开”成参数
		foo.apply(null, [2, 3]); // a:2, b:3
		// 使用 bind(..) 进行柯里化
		var bar = foo.bind(null, 2);
		bar(3); // a:2, b:3
		// 这两种方法都需要传入一个参数当作this 的绑定对象。如果函数并不关心this 的话，你仍然需要传入一个占位值，这时null 可能是一个不错的选择，就像代码所示的那样。
		// 在ES6 中，可以用... 操作符代替apply(..) 来“展开”数组，foo(...[1,2]) 和foo(1,2) 是一样的，这样可以避免不必要的this 绑定。可惜，在ES6 中没有柯里化的相关语法，因此还是需要使用bind(..)。
		
	</script>
</body>
</html>